# -*- coding: utf-8 -*-
"""
@Project: Quantitative Strategy Backtesting Framework
@File   : strategy_factor_RP.py
@Author : Generated by Copilot
@Date   : 2025-11-22

@Description:
PCA 构造宏观因子并进行“因子风险平价”（Risk Parity on PCA factors），随后反推资产权重进行回测。
流程：以指数总表中的资产列为基础，按月滚动窗口做 OAS 协方差估计 -> PCA 提取前 k 个主成分（根据 n_factors 或累计解释率阈值）-> 
在因子协方差（对角阵=特征值）上做风险平价得到因子组合权重 -> 通过最小二乘（SLSQP，long-only/总和为1）反推出资产权重。

本版本已对齐 MultiLayer 结构，支持 Varimax 旋转和更精细的因子映射优化。
"""

import os
import numpy as np
import pandas as pd
from typing import Optional, Sequence, Dict
from sklearn.covariance import OAS
from scipy.optimize import minimize
import matplotlib.pyplot as plt

from framework.config import (
    TRADING_DAYS_PER_YEAR_SCALAR,
    COST_PER_SIDE_SCALAR,
    RISK_FREE_RATE_SCALAR_ANNUAL,
    DEFAULT_LOOKBACK_YEARS,
    DEFAULT_MIN_DATA_YEARS,
    MIN_CLEAN_DAYS,
)
from framework.load_data import load_etf_index_returns_by_category, compute_log_returns
from framework.performance import compute_portfolio_returns_and_equity, calculate_performance_metrics
from framework.logging_config import setup_logging, get_logger
from framework.plotting import plot_equity_curve, plot_weights_history
from framework.allocation_utils import (
    to_daily_rebalance_dates,
    choose_num_factors,
    get_risk_contributions_daily,
    solve_risk_parity_weights,
    map_factor_to_asset_weights,
    varimax,
)

# 统一日志
setup_logging(level="INFO", log_to_file=True, filename="logs/strategy_factor_RP.log")
logger = get_logger("strategy.factor_RP")


STRATEGY_MODE = 'Factor_RiskParity_Flat'


def run_strategy(
    *,
    data_dir: str = 'data',
    start_date: Optional[pd.Timestamp | str] = None,
    end_date: Optional[pd.Timestamp | str] = None,
    lookback_years: int = DEFAULT_LOOKBACK_YEARS,
    min_data_years: int = DEFAULT_MIN_DATA_YEARS,
    min_clean_days: int = MIN_CLEAN_DAYS,
    cost_per_side: float = COST_PER_SIDE_SCALAR,
    rf_rate: float = RISK_FREE_RATE_SCALAR_ANNUAL,
    # PCA 因子数量选择
    n_factors: Optional[int] = 4,
    explained_variance_threshold: float = 0.9,
    max_factors: int = 8,
    use_varimax: bool = True,
    auto_plot: bool = False,
    # 资产层分散控制
    asset_weight_cap: float | None = None,
    asset_ridge_alpha: float = 1e-2,
    allow_short: bool = False, # 是否允许做空
) -> dict:
    """运行“PCA 因子风险平价”策略（扁平化版本），返回标准结果字典。
    直接对所有选定资产进行 PCA 提取因子，不做分层。
    """
    
    # 统一解析日期参数
    def _parse_dt(x):
        if x is None: return None
        return pd.to_datetime(x)
    start_dt_global = _parse_dt(start_date)
    end_dt_global = _parse_dt(end_date)

    # 1) 数据加载：按“资产类别”读取 ETF 与指数（仅 Y）
    etf_by_cat, idx_by_cat = load_etf_index_returns_by_category(data_dir=data_dir, returns_index_col='日期')
    logger.info(f"加载到的类别: {list(idx_by_cat.keys())}")

    # 选择类别并合并“指数”为资产池（PCA 会在这些资产上提取因子）
    use_cats = list(idx_by_cat.keys()) 
    logger.info(f"使用的类别筛选: {use_cats}")
    assets_simple = None
    for c in use_cats:
        df = idx_by_cat.get(c)
        if df is None or df.empty:
            continue
        assets_simple = df if assets_simple is None else assets_simple.join(df, how='outer')
    if assets_simple is None or assets_simple.empty:
        raise ValueError(f"所选类别 {use_cats} 未加载到任何指数资产列")
    assets_simple = assets_simple.sort_index()
    
    # 截取时间段
    if start_dt_global:
        assets_simple = assets_simple.loc[start_dt_global:]
    if end_dt_global:
        assets_simple = assets_simple.loc[:end_dt_global]

    logger.info(f"资产池形状: {assets_simple.shape}")

    # 2) 计算 log 收益用于协方差估计（PCA 输入）
    assets_log = compute_log_returns(assets_simple)
    asset_names_all = assets_log.columns.tolist()

    # 3) 月度调仓窗口
    lookback_window = TRADING_DAYS_PER_YEAR_SCALAR * lookback_years
    min_data_days_required = TRADING_DAYS_PER_YEAR_SCALAR * min_data_years
    
    # 确定再平衡日期
    rebalance_dates = to_daily_rebalance_dates(assets_log, min_data_days_required)
    
    # 确保 start_date 被包含
    if start_dt_global is not None:
        future_rebals = rebalance_dates[rebalance_dates >= start_dt_global]
        if start_dt_global not in future_rebals and start_dt_global >= assets_log.index[0] + pd.DateOffset(days=min_data_days_required):
             rebalance_dates = pd.DatetimeIndex([start_dt_global] + list(future_rebals)).sort_values()
        else:
             rebalance_dates = future_rebals

    weights_hist = pd.DataFrame(index=rebalance_dates, columns=asset_names_all, dtype=float).fillna(0.0)
    rc_hist = pd.DataFrame(index=rebalance_dates, columns=asset_names_all, dtype=float).fillna(0.0)

    oas = OAS(assume_centered=True)
    
    for dt in rebalance_dates:
        start_dt = dt - pd.DateOffset(days=lookback_window)
        window_df = assets_log.loc[start_dt:dt]
        
        # 筛选存活资产
        live = window_df.count()[lambda s: s >= min_data_days_required].index.tolist()
        n = len(live)
        # logger.info(f"{dt.date()} 窗口[{start_dt.date()}~{dt.date()}] 成活资产数={n}")
        
        if n < 2:
            continue
            
        clean = window_df[live].dropna()
        if len(clean) < min_clean_days:
            logger.info(f"{dt.date()} 有效样本天数不足: {len(clean)} < {min_clean_days}")
            continue

        # 资产协方差估计（对数收益）
        oas.fit(clean)
        sigma_assets = oas.covariance_
        
        # 波动率向量
        vol_vec = np.sqrt(np.clip(np.diag(sigma_assets), 0.0, None))
        vol_floor = 1e-12
        safe_vol = np.where(vol_vec > vol_floor, vol_vec, vol_floor)
        
        # 相关系数矩阵
        D_inv = np.diag(1.0 / safe_vol)
        corr_matrix = D_inv @ sigma_assets @ D_inv

        # PCA 分解（相关系数矩阵特征分解）
        evals, evecs = np.linalg.eigh(corr_matrix)
        # 倒序排列
        order = np.argsort(evals)[::-1]
        evals = evals[order]
        evecs = evecs[:, order]
        
        # 选择因子数量
        k = choose_num_factors(evals, n_factors=n_factors, explained_var_threshold=explained_variance_threshold, max_factors=min(max_factors, n))
        
        evals_k = np.clip(evals[:k], 0.0, None)
        V_k = evecs[:, :k]
        
        # Varimax 旋转 (可选)
        if use_varimax and k > 1:
            # 构造载荷矩阵 L = V * sqrt(Lambda)
            loadings = V_k * np.sqrt(evals_k)
            
            # 进行旋转
            R = varimax(loadings)
            
            # 旋转后的载荷矩阵
            loadings_rot = loadings @ R
            
            # 旋转后的特征向量 (基向量) V_rot = V_k @ R
            V_rot = V_k @ R
            
            # 旋转后的因子协方差矩阵
            sigma_f_rot = R.T @ np.diag(evals_k) @ R
            
            # 使用旋转后的协方差矩阵求解风险平价权重
            w_f = solve_risk_parity_weights(sigma_f_rot, None)
            
            # 使用旋转后的基向量映射回资产权重
            V_target = V_rot
            
            # logger.info(f"PCA(Varimax): k={k} 已应用旋转")
        else:
            sigma_f = np.diag(evals_k)
            w_f = solve_risk_parity_weights(sigma_f, None)
            V_target = V_k
            sigma_f_rot = sigma_f # Alias for consistency

        # 准备因子协方差矩阵用于映射优化 (最小化跟踪误差方差)
        target_sigma_f = sigma_f_rot if (use_varimax and k > 1) else np.diag(evals_k)

        # 从因子权重反推出资产权重
        # 注意：这里是在标准化空间进行的映射
        w_asset_std = map_factor_to_asset_weights(
            V_target,
            w_f,
            weight_cap=None, # 暂不在此处限制，后续归一化处理
            ridge_alpha=asset_ridge_alpha,
            factor_cov_matrix=target_sigma_f,
            allow_short=allow_short,
            enforce_budget_constraint=False # 关键：不强制和为1，优先匹配因子暴露
        )
        
        # 验证因子暴露拟合情况 (在标准化空间)
        actual_exposure = V_target.T @ w_asset_std
        exposure_diff = np.linalg.norm(actual_exposure - w_f)
        
        # 计算余弦相似度
        norm_target = np.linalg.norm(w_f)
        norm_actual = np.linalg.norm(actual_exposure)
        if norm_target > 1e-9 and norm_actual > 1e-9:
            cosine_sim = np.dot(w_f, actual_exposure) / (norm_target * norm_actual)
        else:
            cosine_sim = 0.0
            
        # 计算实际组合在因子层面的风险贡献 (Actual Factor RC)
        mrc_factor_actual = target_sigma_f @ actual_exposure
        rc_factor_actual = actual_exposure * mrc_factor_actual
        rc_f_pct_actual = rc_factor_actual / rc_factor_actual.sum() if rc_factor_actual.sum() > 0 else rc_factor_actual
        
        logger.info(f"[{dt.date()}] k={k} 拟合度: Cosine={cosine_sim:.4f}, Diff={exposure_diff:.4f}")
        logger.info(f"  -> 实际因子RC分布: {np.round(rc_f_pct_actual, 3)} (Target: Equal)")

        # 回到原尺度 (物理空间)
        # w_physical = w_std / vol
        w_asset_physical = w_asset_std / np.where(vol_vec > 0, vol_vec, 1e-8)
        
        # 处理做空与归一化
        if not allow_short:
            w_asset_physical = np.maximum(w_asset_physical, 0)
            
        s_total = w_asset_physical.sum()
        if abs(s_total) > 1e-9:
            w_asset_physical = w_asset_physical / s_total
        
        # 应用单资产权重上限 (简单截断再归一化，可能会破坏因子暴露，但在实盘中必须要有)
        if asset_weight_cap is not None:
            w_asset_physical = np.clip(w_asset_physical, -asset_weight_cap if allow_short else 0, asset_weight_cap)
            s_total = w_asset_physical.sum()
            if abs(s_total) > 1e-9:
                w_asset_physical = w_asset_physical / s_total

        # 记录权重
        weights_hist.loc[dt, live] = w_asset_physical
        
        # 记录资产RC
        rc_asset = get_risk_contributions_daily(w_asset_physical, sigma_assets)
        rc_hist.loc[dt, live] = rc_asset
        
        # 打印 Top 权重
        order_w = np.argsort(w_asset_physical)[::-1]
        top_idx = order_w[: min(5, len(order_w))]
        top_names = [live[i] for i in top_idx]
        top_vals = [w_asset_physical[i] for i in top_idx]
        top_str = ", ".join([f"{n}:{v:.2%}" for n, v in zip(top_names, top_vals)])
        # logger.info(f"  -> Top Assets: {top_str}")


    # 4) 回测
    _,port_ret, _,equity, daily_w = compute_portfolio_returns_and_equity(
        weights_history_df=weights_hist,
        daily_returns_df=assets_simple.loc[weights_hist.index[0]:],
        cost_per_side_scalar=cost_per_side,
    )
    
    equity.name = STRATEGY_MODE
    report = calculate_performance_metrics(port_ret, equity, rf_rate, TRADING_DAYS_PER_YEAR_SCALAR)

    total_cost_series = (weights_hist.diff().abs().sum(axis=1).astype('float64') * cost_per_side).shift(1)
    total_cost_series = total_cost_series.reindex(port_ret.index).astype('float64').fillna(0.0)
    total_cost = float(total_cost_series.sum())
    logger.info(f"总交易成本={total_cost:.6f}")

    figures = {}
    if auto_plot:
        fig1 = plot_equity_curve(equity, report, STRATEGY_MODE, auto_show=False)
        fig2 = plot_weights_history(weights_hist, STRATEGY_MODE, reverse_legend=True, auto_show=False)
        plt.show()
        figures = {'equity': fig1, 'weights': fig2}

    return {
        'weights_history_df': weights_hist,
        'rc_history_df': rc_hist,
        'final_portfolio_returns_series': port_ret,
        'equity_curve_series': equity,
        'performance_report': report,
        'total_cost': total_cost,
        'figures': figures,
    }


if __name__ == "__main__":
    setup_logging(level="INFO")
    logger.info("运行 扁平化因子风险平价 (Flat PCA-RP)…")
    res = run_strategy(
        data_dir='data',
        auto_plot=True,
        asset_weight_cap = None,
        n_factors = 4,
        use_varimax = True,
        allow_short = False, # 设为 False 以验证在多资产下是否能更好拟合
        start_date="20200101",
        end_date="20251031",
    )
    perf = res['performance_report']
    logger.info("运行完成，主要指标：")
    for k, v in perf.items():
        if any(x in k for x in ['CAGR', 'Vol', '回撤']):
            logger.info(f"  {k}: {v:.2%}")
        else:
            logger.info(f"  {k}: {v:.4f}")
